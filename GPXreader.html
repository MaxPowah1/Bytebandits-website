<!doctype html>
<html lang="de">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>MotoLeanX GPX Viewer (Lean/Speed-Overlay)</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <style>
        /* Vollhöhe + Flex-Layout */
        html, body { height: 100%; margin: 0; }
        body {
          min-height: 100dvh;          /* korrekt mit Mobile-Adressleiste */
          display: flex;
          flex-direction: column;
        }

        /* Topbar bleibt oben, Karte füllt den Rest */
        .topbar {
          display:flex; gap:12px; align-items:center; padding:10px 12px;
          background:#fff; border-bottom:1px solid #ddd; font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial;
          flex-wrap: wrap;
          flex: 0 0 auto;
        }

        /* Karte bekommt flex:1 statt fixer Höhe */
        #map {
          flex: 1 1 auto;
          min-height: 0;               /* wichtig, damit flex-Child schrumpfen darf */
        }

        .hud {
          margin-left:auto; padding:8px 12px; border-radius:12px; border:1px solid #ddd; background:#fafafa;
          font-weight:600; min-width:190px; text-align:center;
        }
        .controls { display:flex; align-items:center; gap:8px; }
        .legend { font-size:12px; opacity:.95; display:flex; gap:24px; flex-wrap:wrap; align-items:flex-start; }
        .legend .block { display:flex; flex-direction:column; gap:6px; }
        .legend .title { font-weight:600; }
        .chip { display:inline-flex; align-items:center; gap:6px; padding:4px 8px; border:1px solid #ddd; border-radius:12px; background:#fff; }
        .swatch { width:14px; height:14px; border-radius:3px; display:inline-block; }
        #slider { width:320px; }
        input[type="file"] { display:none; }
        label.button, button, .seg button {
          padding:8px 12px; border:1px solid #ddd; border-radius:10px; background:#fff; cursor:pointer; font-weight:600;
        }
        button:disabled { opacity:.5; cursor:not-allowed; }
        .seg { display:inline-flex; border:1px solid #ddd; border-radius:12px; overflow:hidden; }
        .seg button { border:0; padding:8px 14px; }
        .seg button.active { background:#111; color:#fff; }

        /* Skalen */
        .scale { width:320px; height:14px; border-radius:6px; border:1px solid #ddd; position:relative; }
        .ticks { display:flex; justify-content:space-between; width:320px; font-variant-numeric: tabular-nums; }
    </style>
</head>
<body>
<div class="topbar">
    <label class="button">
        GPX laden
        <input id="fileInput" type="file" accept=".gpx,application/gpx+xml" />
    </label>

    <div class="seg" role="tablist" aria-label="Layer">
        <button id="modeLean" class="active" role="tab" aria-selected="true">Lean</button>
        <button id="modeSpeed" role="tab" aria-selected="false">Speed</button>
    </div>

    <div class="controls">
        <button id="playBtn" disabled>▶︎</button>
        <input id="slider" type="range" min="0" max="0" value="0" step="1" disabled />
        <span id="timeLbl" class="chip">Zeit: –</span>
    </div>

    <div id="legend" class="legend"></div>

    <div id="hud" class="hud">Lean: – °</div>
</div>

<div id="map"></div>

<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<script>
    const map = L.map('map', { zoomControl: true }).setView([51, 10], 6);
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      maxZoom: 19, attribution: '&copy; OpenStreetMap'
    }).addTo(map);

    const fileInput = document.getElementById('fileInput');
    const slider = document.getElementById('slider');
    const playBtn = document.getElementById('playBtn');
    const timeLbl = document.getElementById('timeLbl');
    const hud = document.getElementById('hud');
    const legend = document.getElementById('legend');
    const modeLeanBtn = document.getElementById('modeLean');
    const modeSpeedBtn = document.getElementById('modeSpeed');

    let points = [];
    let segLayers = [];
    let marker = null;
    let animTimer = null;
    let currentMode = 'lean';

    const LEAN_MAX = 75;
    const SPEED_MAX = 300;

    function colorForLean(lean) {
      const a = Math.min(Math.abs(lean), LEAN_MAX) / LEAN_MAX;
      const intensity = Math.round(70 + a * 185);
      if (lean >= 0) return `rgb(${intensity},60,60)`;
      return `rgb(43,108,176)`;
    }
    function colorForSpeed(speedKmh) {
      const v = Math.max(0, Math.min(speedKmh, SPEED_MAX)) / SPEED_MAX;
      const hue = 220 * (1 - v);
      return `hsl(${hue} 85% 45%)`;
    }

    function setLegend(mode) {
      if (mode === 'lean') {
        let ticks = '';
        for (let deg = 0; deg <= LEAN_MAX; deg += 15) { ticks += `<span>${deg}°</span>`; }
        legend.innerHTML = `
          <div class="block">
            <div class="title">Lean links (°)</div>
            <div class="scale" style="background: linear-gradient(90deg, rgba(43,108,176,0.2), rgba(43,108,176,1));"></div>
            <div class="ticks">${ticks}</div>
          </div>
          <div class="block">
            <div class="title">Lean rechts (°)</div>
            <div class="scale" style="background: linear-gradient(90deg, rgba(255,70,70,0.25), rgb(255,60,60));"></div>
            <div class="ticks">${ticks}</div>
          </div>
        `;
      } else {
        let ticks = '';
        for (let v = 0; v <= SPEED_MAX; v += 50) { ticks += `<span>${v}</span>`; }
        legend.innerHTML = `
          <div class="block">
            <div class="title">Speed (km/h)</div>
            <div class="scale" style="background: linear-gradient(90deg, hsl(220 85% 45%), hsl(0 85% 45%));"></div>
            <div class="ticks">${ticks}</div>
          </div>
        `;
      }
      map.invalidateSize();          // <— neu: nach Layout-Änderungen
    }

    function clearMap() {
      segLayers.forEach(l => map.removeLayer(l));
      segLayers = [];
      if (marker) { map.removeLayer(marker); marker = null; }
      points = [];
      slider.disabled = true;
      playBtn.disabled = true;
      timeLbl.textContent = 'Zeit: –';
      hud.textContent = currentMode === 'lean' ? 'Lean: – °' : 'Speed: – km/h';
    }

    function drawTrack() {
      if (points.length < 2) return;
      const bounds = L.latLngBounds(points.map(p => [p.lat, p.lon]));
      map.fitBounds(bounds.pad(0.2));
      redrawSegments();
      marker = L.circleMarker([points[0].lat, points[0].lon], {
        radius: 7, weight: 2, color: '#222', fillColor: '#fff', fillOpacity: 1
      }).addTo(map);
      slider.min = 0;
      slider.max = String(points.length - 1);
      slider.value = 0;
      slider.disabled = false;
      playBtn.disabled = false;
      updateHUD(0);
      map.invalidateSize();          // <— neu: sicherstellen, dass die Karte die Flex-Höhe kennt
    }

    function redrawSegments() {
      segLayers.forEach(l => map.removeLayer(l));
      segLayers = [];
      for (let i = 1; i < points.length; i++) {
        const p0 = points[i-1], p1 = points[i];
        const value = currentMode === 'lean' ? p0.lean : p0.speed;
        const clr = currentMode === 'lean' ? colorForLean(value) : colorForSpeed(value);
        const seg = L.polyline([[p0.lat, p0.lon], [p1.lat, p1.lon]], {
          color: clr, weight: 5, opacity: 0.9
        }).addTo(map);
        segLayers.push(seg);
      }
      setLegend(currentMode);
    }

    function updateHUD(i) {
      const p = points[i];
      if (!p) return;
      marker.setLatLng([p.lat, p.lon]);
      if (currentMode === 'lean') {
        hud.textContent = `Lean: ${isFinite(p.lean) ? p.lean.toFixed(2) : '–'} °`;
      } else {
        hud.textContent = `Speed: ${isFinite(p.speed) ? p.speed.toFixed(1) : '–'} km/h`;
      }
      timeLbl.textContent = 'Zeit: ' + (p.time ? p.time.toISOString() : '–');
    }

    slider.addEventListener('input', () => {
      stopAnim();
      updateHUD(parseInt(slider.value, 10));
    });
    playBtn.addEventListener('click', () => {
      if (animTimer) { stopAnim(); return; }
      playBtn.textContent = '⏸';
      let i = parseInt(slider.value, 10);
      animTimer = setInterval(() => {
        if (i >= points.length) { stopAnim(); return; }
        slider.value = i;
        updateHUD(i);
        i++;
      }, 100);
    });
    function stopAnim() {
      if (animTimer) { clearInterval(animTimer); animTimer = null; }
      playBtn.textContent = '▶︎';
    }

    function setMode(mode) {
      if (mode === currentMode) return;
      currentMode = mode;
      modeLeanBtn.classList.toggle('active', mode === 'lean');
      modeSpeedBtn.classList.toggle('active', mode === 'speed');
      hud.textContent = mode === 'lean' ? 'Lean: – °' : 'Speed: – km/h';
      redrawSegments();
      updateHUD(parseInt(slider.value, 10) || 0);
    }
    modeLeanBtn.addEventListener('click', () => setMode('lean'));
    modeSpeedBtn.addEventListener('click', () => setMode('speed'));
    window.addEventListener('keydown', (e) => {
      if (e.key.toLowerCase() === 'l') setMode('lean');
      if (e.key.toLowerCase() === 's') setMode('speed');
    });

    function haversineKm(lat1, lon1, lat2, lon2) {
      const R = 6371; const toRad = d => d * Math.PI / 180;
      const dLat = toRad(lat2 - lat1), dLon = toRad(lon2 - lon1);
      const a = Math.sin(dLat/2)**2 + Math.cos(toRad(lat1))*Math.cos(toRad(lat2))*Math.sin(dLon/2)**2;
      return 2 * R * Math.asin(Math.sqrt(a));
    }

    fileInput.addEventListener('change', async (e) => {
      const file = e.target.files?.[0];
      if (!file) return;
      clearMap();
      const text = await file.text();
      const xml = new DOMParser().parseFromString(text, "application/xml");

      const trkpts = xml.getElementsByTagNameNS('http://www.topografix.com/GPX/1/1', 'trkpt');
      const tmp = [];
      for (const node of trkpts) {
        const lat = parseFloat(node.getAttribute('lat'));
        const lon = parseFloat(node.getAttribute('lon'));
        const timeNode = node.getElementsByTagName('time')[0];
        const extNode = node.getElementsByTagName('extensions')[0];
        let lean = NaN, speed = NaN;
        if (extNode) {
          const leanNode = extNode.getElementsByTagName('lean')[0];
          if (leanNode && leanNode.textContent) lean = parseFloat(leanNode.textContent);
          const speedNode = extNode.getElementsByTagName('speed')[0];
          if (speedNode && speedNode.textContent) speed = parseFloat(speedNode.textContent);
        }
        const time = timeNode ? new Date(timeNode.textContent) : null;
        if (!Number.isNaN(lat) && !Number.isNaN(lon) && !Number.isNaN(lean)) {
          tmp.push({ lat, lon, time, lean, speed });
        }
      }
      if (tmp.length < 2) { alert('Zu wenige Punkte gefunden.'); return; }
      // Speed fallback
      for (let i = 0; i < tmp.length; i++) {
        if (!isFinite(tmp[i].speed)) {
          const i0 = Math.max(0, i - 1), i1 = Math.min(tmp.length - 1, i + 1);
          const p0 = tmp[i0], p1 = tmp[i1];
          if (p0.time && p1.time && p1.time > p0.time) {
            const distKm = haversineKm(p0.lat, p0.lon, p1.lat, p1.lon);
            const dtH = (p1.time - p0.time) / 3600000;
            tmp[i].speed = dtH > 0 ? (distKm / dtH) : 0;
          } else tmp[i].speed = 0;
        }
      }
      points = tmp;
      drawTrack();
      setLegend(currentMode);
    });


    window.addEventListener('resize', () => map.invalidateSize());
    window.addEventListener('load', () => map.invalidateSize());

    setLegend(currentMode);
</script>
</body>
</html>
